import { tools as rawTools } from "../tools/registry";
import { Agent } from "../models/Agent";
import { logger } from "../lib/logger";

/**
 * Executes a tool decision generated by the agent
 * Separates tool execution from agent reasoning
 */

interface ToolDecision {
  type: "tool" | "agent";
  target: string;
  args?: Record<string, any>;
}

interface ExecutionResult {
  success: boolean;
  result?: any;
  error?: string;
}

// Get tool by name
const getToolByName = (name: string) => {
  return rawTools.find((t: any) => {
    return (
      t.name === name || t.toolName === name || (t.tool && t.tool.name === name)
    );
  });
};

// Extract execute or invoke function from tool
const getExecuteFn = (tool: any): Function | undefined => {
  if (!tool) return undefined;

  // Try invoke first (OpenAI tool() format)
  if (typeof tool.invoke === "function") {
    return tool.invoke;
  }

  // Try execute
  if (typeof tool.execute === "function") {
    return tool.execute;
  }

  // Try nested
  if (tool.tool?.invoke && typeof tool.tool.invoke === "function") {
    return tool.tool.invoke;
  }

  if (tool.tool?.execute && typeof tool.tool.execute === "function") {
    return tool.tool.execute;
  }

  return undefined;
};

/**
 * Execute a tool decision
 */
export const executeTool = async (
  decision: ToolDecision,
  userId?: string
): Promise<ExecutionResult> => {
  try {
    console.log("[toolExecutor] Executing tool decision:", {
      type: decision.type,
      target: decision.target,
      argsKeys: Object.keys(decision.args || {}),
    });

    if (decision.type !== "tool") {
      return {
        success: false,
        error: `Executor only handles tool decisions. Got: ${decision.type}`,
      };
    }

    const toolName = decision.target;
    const tool = getToolByName(toolName);

    if (!tool) {
      const availableTools = rawTools
        .map((t: any) => t.name || t.toolName)
        .filter(Boolean)
        .join(", ");
      return {
        success: false,
        error: `Tool not found: ${toolName}. Available: ${availableTools}`,
      };
    }

    console.log("[toolExecutor] Tool found:", toolName);

    const execFn = getExecuteFn(tool);
    console.log("[toolExecutor] Tool object structure:", {
      hasInvoke: typeof tool.invoke === "function",
      hasExecute: typeof tool.execute === "function",
      hasTool: !!tool.tool,
      toolKeys: Object.keys(tool),
      toolType: tool.constructor?.name,
    });

    if (!execFn) {
      return {
        success: false,
        error: `Tool ${toolName} has no executable function`,
      };
    }

    console.log("[toolExecutor] Executing function...");

    // Clean args for JSON safety
    const cleanArgs = JSON.parse(JSON.stringify(decision.args || {}));

    console.log("[toolExecutor] Clean args:", {
      type: typeof cleanArgs,
      keys: Object.keys(cleanArgs),
      preview: JSON.stringify(cleanArgs).substring(0, 200),
    });

    // Call the tool with context
    const context = {
      context: {
        caller: "axle",
        userId,
      },
    };

    let result;
    try {
      // Try with context
      result = await execFn(cleanArgs, context as any);
    } catch (err) {
      // Fallback: try without context
      console.warn(
        "[toolExecutor] First attempt failed, trying without context:",
        (err as any)?.message
      );
      try {
        result = await execFn(cleanArgs);
      } catch (err2) {
        console.error("[toolExecutor] Both attempts failed:", {
          err1: (err as any)?.message,
          err2: (err2 as any)?.message,
        });
        throw err; // throw original error
      }
    }

    console.log("[toolExecutor] Tool execution result:", {
      type: typeof result,
      hasError: typeof result === "string" && result.includes("Error"),
    });

    // Check if result contains an error message
    if (typeof result === "string" && result.includes("Error")) {
      return {
        success: false,
        error: result,
      };
    }

    return {
      success: true,
      result,
    };
  } catch (err) {
    const errorMsg = (err as any)?.message || String(err);
    console.error("[toolExecutor] Error executing tool:", errorMsg);
    return {
      success: false,
      error: errorMsg,
    };
  }
};

/**
 * Execute an agent decision (delegate to another agent)
 */
export const executeAgent = async (
  decision: ToolDecision,
  userId?: string
): Promise<ExecutionResult> => {
  try {
    console.log("[toolExecutor] Executing agent decision:", {
      target: decision.target,
      input: decision.args?.input,
    });

    if (decision.type !== "agent") {
      return {
        success: false,
        error: `This handler only processes agent decisions. Got: ${decision.type}`,
      };
    }

    // Find the agent
    const agentId = decision.target;
    const agent = await Agent.findById(agentId).lean();

    if (!agent) {
      return {
        success: false,
        error: `Agent not found: ${agentId}`,
      };
    }

    console.log("[toolExecutor] Agent found:", agent.name);

    // Import dynamically to avoid circular dependencies
    const axleAgent = (await import("../agent/main")).default;

    // Run the agent
    const result = await axleAgent.run({
      input: decision.args?.input || "",
      userId: userId || String(agent.ownerId),
      context: {
        agentId,
        delegatedFrom: "parentAgent",
      },
    });

    console.log("[toolExecutor] Agent execution completed");

    return {
      success: true,
      result,
    };
  } catch (err) {
    const errorMsg = (err as any)?.message || String(err);
    console.error("[toolExecutor] Error executing agent:", errorMsg);
    return {
      success: false,
      error: errorMsg,
    };
  }
};

/**
 * Execute any decision (tool or agent)
 */
export const executeDecision = async (
  decision: ToolDecision,
  userId?: string
): Promise<ExecutionResult> => {
  console.log("[toolExecutor] Executing decision:", {
    type: decision.type,
    target: decision.target,
  });

  if (decision.type === "tool") {
    return executeTool(decision, userId);
  } else if (decision.type === "agent") {
    return executeAgent(decision, userId);
  } else {
    return {
      success: false,
      error: `Unknown decision type: ${decision.type}`,
    };
  }
};
